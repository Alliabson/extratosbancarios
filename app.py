import streamlit as st
import pandas as pd
import fitz  # PyMuPDF
import re
from datetime import datetime
import json
import google.generativeai as genai
import traceback

# --- CONFIGURA√á√ÉO INICIAL ---
st.set_page_config(layout="wide", page_title="Analisador de Extratos Banc√°rios")
st.title("üìä Analisador de Extratos Banc√°rios com IA")
st.write("Fa√ßa o upload dos seus extratos em PDF para an√°lise completa.")

# --- FUN√á√ïES PRINCIPAIS ---

@st.cache_data
def extract_text_from_pdf(file_content: bytes) -> str:
    """Extrai texto de TODAS as p√°ginas do PDF."""
    full_text = ""
    try:
        with fitz.open(stream=file_content, filetype="pdf") as doc:
            num_pages = len(doc)
            st.sidebar.info(f"üìÑ PDF com {num_pages} p√°gina(s)")
            
            for page_num, page in enumerate(doc, 1):
                page_text = page.get_text()
                full_text += page_text + "\n"
                
            st.sidebar.info(f"üìä {len(full_text)} caracteres extra√≠dos")
                
    except Exception as e:
        st.error(f"‚ùå Erro ao ler PDF: {e}")
        return ""
    
    return full_text

def parse_amount(amount_str: str) -> float:
    """Converte valor monet√°rio para float."""
    try:
        # Remove R$, pontos e espa√ßos
        cleaned = str(amount_str).replace('R$', '').replace('.', '').replace(' ', '')
        # Substitui v√≠rgula por ponto para decimal
        cleaned = cleaned.replace(',', '.')
        # Verifica se √© negativo
        is_negative = '-' in cleaned
        cleaned = cleaned.replace('-', '')
        
        value = float(cleaned)
        return -value if is_negative else value
    except:
        return 0.0

def parse_date(date_str: str) -> datetime:
    """Tenta parsear data em m√∫ltiplos formatos."""
    try:
        # Primeiro tenta o formato mais comum DD/MM/AAAA
        try:
            return pd.to_datetime(date_str, format='%d/%m/%Y')
        except:
            pass
        
        # Tenta outros formatos
        formats_to_try = [
            '%d-%m-%Y', '%d.%m.%Y', '%Y/%m/%d', '%d/%m/%y',
            '%d de %B de %Y', '%d de %b de %Y', '%B %Y', '%b %Y'
        ]
        
        for fmt in formats_to_try:
            try:
                return pd.to_datetime(date_str, format=fmt)
            except:
                continue
                
        # √öltima tentativa com parser flex√≠vel
        return pd.to_datetime(date_str, errors='coerce')
    except:
        return pd.NaT

def extract_transactions_with_gemini(text: str, api_key: str) -> list:
    """Usa Gemini AI para extrair transa√ß√µes de qualquer formato de extrato."""
    if not api_key:
        st.error("‚ùå Chave API n√£o configurada")
        return []
    
    try:
        genai.configure(api_key=api_key)
        model = genai.GenerativeModel('gemini-1.5-flash')
        
        prompt = f"""
        ANALISE ESTE EXTRATO BANC√ÅRIO E EXTRAIA TODAS AS TRANSA√á√ïES FINANCEIRAS.

        REGRAS:
        1. Extraia CADA transa√ß√£o individual
        2. Data no formato DD/MM/AAAA
        3. Descri√ß√£o COMPLETA da transa√ß√£o
        4. Valor num√©rico com negativo para D√âBITOS e positivo para CR√âDITOS
        5. IGNORE saldos, totais, cabe√ßalhos e rodap√©s

        FORMATO DE SA√çDA EXCLUSIVAMENTE JSON:
        [
          {{"date": "01/01/2025", "description": "DESCRI√á√ÉO COMPLETA", "amount": -100.00}},
          {{"date": "02/01/2025", "description": "OUTRA DESCRI√á√ÉO", "amount": 500.00}}
        ]

        TEXTO DO EXTRATO:
        {text[:10000]}  # Limite para n√£o exceder tokens

        RETORNE APENAS O JSON, SEM TEXTOS ADICIONAIS.
        """

        with st.spinner("ü§ñ IA analisando extrato..."):
            response = model.generate_content(prompt)
            
        # Limpa a resposta
        response_text = response.text.strip()
        
        # Remove marca√ß√µes de c√≥digo
        if response_text.startswith("```json"):
            response_text = response_text[7:]
        if response_text.endswith("```"):
            response_text = response_text[:-3]
        if response_text.startswith("```"):
            response_text = response_text[3:]
        
        # Parse do JSON
        transactions = json.loads(response_text)
        
        # Processa as transa√ß√µes
        processed_transactions = []
        for transaction in transactions:
            try:
                date_obj = parse_date(transaction['date'])
                if pd.isna(date_obj):
                    continue
                    
                processed_transactions.append({
                    'date': date_obj,
                    'description': transaction['description'],
                    'amount': float(transaction['amount'])
                })
            except:
                continue
        
        return processed_transactions
        
    except Exception as e:
        st.error(f"‚ùå Erro no Gemini: {str(e)}")
        st.error("Detalhes: " + traceback.format_exc())
        return []

def categorize_transaction(description: str) -> str:
    """Categoriza transa√ß√µes automaticamente."""
    if not isinstance(description, str):
        return 'Outros'
    
    desc = description.lower()
    
    categories = {
        'Receita': ['sal√°rio', 'salario', 'rendimento', 'dep√≥sito', 'deposito', 'pix receb', 'transfer√™ncia receb', 'ted receb'],
        'Alimenta√ß√£o': ['supermercado', 'mercado', 'restaurante', 'lanche', 'padaria', 'a√ßai', 'pizza', 'ifood', 'mcdonald'],
        'Moradia': ['aluguel', 'condom√≠nio', 'condominio', 'luz', '√°gua', 'agua', 'energia', 'internet', 'telefone'],
        'Transporte': ['uber', '99', 'taxi', '√¥nibus', 'onibus', 'metro', 'combust√≠vel', 'combustivel', 'posto', 'estacionamento'],
        'Sa√∫de': ['farmacia', 'drogaria', 'hospital', 'm√©dico', 'medico', 'dentista', 'plano de sa√∫de'],
        'Educa√ß√£o': ['escola', 'faculdade', 'curso', 'livro', 'material escolar'],
        'Lazer': ['cinema', 'netflix', 'spotify', 'viagem', 'hotel', 'show'],
        'Servi√ßos': ['conserto', 'manuten√ß√£o', 'manutencao', 'assist√™ncia', 'assistencia'],
        'Compras': ['shopping', 'loja', 'ecommerce', 'amazon', 'mercado livre'],
        'Investimentos': ['a√ß√£o', 'acao', 'fundo', 'investimento', 'cripto', 'bitcoin'],
        'Taxas': ['tarifa', 'anuidade', 'juros', 'multa', 'iof']
    }
    
    for category, keywords in categories.items():
        if any(keyword in desc for keyword in keywords):
            return category
            
    return 'Outros'

# --- INTERFACE PRINCIPAL ---

# Configura√ß√£o inicial
if 'transactions' not in st.session_state:
    st.session_state.transactions = []
if 'excluded_ids' not in st.session_state:
    st.session_state.excluded_ids = set()

# Verificar chave API
if "gemini_api_key" not in st.secrets:
    st.error("""
    ‚ùå Chave do Gemini AI n√£o encontrada!
    
    Por favor, adicione sua chave API nas configura√ß√µes do Streamlit:
    1. Acesse https://makersuite.google.com/
    2. Crie uma API key
    3. Adicione no secrets.toml: gemini_api_key = "sua-chave-aqui"
    """)
    st.stop()

# Sidebar
with st.sidebar:
    st.header("‚öôÔ∏è Controles")
    st.success("‚úÖ Gemini AI configurado")
    
    uploaded_files = st.file_uploader(
        "üì§ Selecione os extratos PDF",
        type="pdf",
        accept_multiple_files=True,
        help="Podem ser v√°rios arquivos de diferentes bancos"
    )
    
    st.markdown("---")
    filter_name = st.text_input(
        "üë§ Filtrar por nome:",
        help="Digite seu nome para remover transfer√™ncias internas"
    )

# Processamento principal
if uploaded_files:
    if st.button("üîÑ Processar Extratos", type="primary"):
        with st.spinner("Processando arquivos..."):
            all_transactions = []
            
            for uploaded_file in uploaded_files:
                st.sidebar.info(f"üìÇ Processando: {uploaded_file.name}")
                
                # Extrai texto do PDF
                text = extract_text_from_pdf(uploaded_file.getvalue())
                
                if not text or len(text.strip()) < 100:
                    st.error(f"‚ùå Arquivo {uploaded_file.name} est√° vazio ou inv√°lido")
                    continue
                
                # Extrai transa√ß√µes com Gemini AI
                transactions = extract_transactions_with_gemini(
                    text, 
                    st.secrets["gemini_api_key"]
                )
                
                if transactions:
                    all_transactions.extend(transactions)
                    st.sidebar.success(f"‚úÖ {uploaded_file.name}: {len(transactions)} transa√ß√µes")
                else:
                    st.sidebar.error(f"‚ùå {uploaded_file.name}: Nenhuma transa√ß√£o encontrada")
            
            if all_transactions:
                # Cria DataFrame
                df = pd.DataFrame(all_transactions)
                df['category'] = df['description'].apply(categorize_transaction)
                df = df.sort_values('date', ascending=False)
                df.reset_index(inplace=True)
                df.rename(columns={'index': 'id'}, inplace=True)
                
                st.session_state.transactions = df
                st.session_state.excluded_ids = set()
                st.success(f"‚úÖ An√°lise conclu√≠da! {len(df)} transa√ß√µes encontradas.")
            else:
                st.error("‚ùå Nenhuma transa√ß√£o foi encontrada em nenhum arquivo.")

# Exibir resultados se existirem transa√ß√µes
if not st.session_state.transactions.empty:
    df = st.session_state.transactions.copy()
    
    # Aplicar filtro de nome se especificado
    if filter_name:
        mask = ~df['description'].str.contains(filter_name, case=False, na=False)
        df = df[mask]
        st.sidebar.info(f"üë§ Filtrado: {filter_name}")
    
    # Remover transa√ß√µes exclu√≠das
    if st.session_state.excluded_ids:
        df = df[~df['id'].isin(st.session_state.excluded_ids)]
    
    # M√©tricas principais
    st.header("üìà An√°lise Financeira")
    
    total_income = df[df['amount'] > 0]['amount'].sum()
    total_expenses = df[df['amount'] < 0]['amount'].sum()
    net_balance = total_income + total_expenses  # expenses j√° s√£o negativos
    
    # C√°lculo de meses - m√©todo mais robusto
    if not df.empty and 'date' in df.columns:
        df['year_month'] = df['date'].dt.to_period('M')
        unique_months = df['year_month'].nunique()
        months_analyzed = max(unique_months, 1)
        
        # Mostrar meses detectados
        months_list = sorted(df['year_month'].astype(str).unique())
        st.sidebar.info(f"üìÖ Meses detectados: {', '.join(months_list)}")
    else:
        months_analyzed = 1
    
    average_income = total_income / months_analyzed if months_analyzed > 0 else 0
    capacity_30 = average_income * 0.3
    
    # Layout de m√©tricas
    col1, col2, col3, col4 = st.columns(4)
    col1.metric("üí∞ Entradas", f"R$ {total_income:,.2f}".replace(',', 'X').replace('.', ',').replace('X', '.'))
    col2.metric("üí∏ Sa√≠das", f"R$ {abs(total_expenses):,.2f}".replace(',', 'X').replace('.', ',').replace('X', '.'))
    col3.metric("‚öñÔ∏è Saldo", f"R$ {net_balance:,.2f}".replace(',', 'X').replace('.', ',').replace('X', '.'))
    col4.metric("üìÖ Meses", months_analyzed)
    
    col5, col6 = st.columns(2)
    col5.metric("üìä M√©dia Mensal", f"R$ {average_income:,.2f}".replace(',', 'X').replace('.', ',').replace('X', '.'))
    col6.metric("üéØ Capacidade 30%", f"R$ {capacity_30:,.2f}".replace(',', 'X').replace('.', ',').replace('X', '.'))
    
    # An√°lise por categoria
    st.subheader("üóÇÔ∏è An√°lise por Categoria")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.write("**üìâ Despesas por Categoria**")
        expenses = df[df['amount'] < 0].groupby('category')['amount'].sum().abs().sort_values(ascending=False)
        for category, amount in expenses.items():
            st.write(f"{category}: R$ {amount:,.2f}".replace(',', 'X').replace('.', ',').replace('X', '.'))
    
    with col2:
        st.write("**üìà Receitas por Categoria**")
        income = df[df['amount'] > 0].groupby('category')['amount'].sum().sort_values(ascending=False)
        for category, amount in income.items():
            st.write(f"{category}: R$ {amount:,.2f}".replace(',', 'X').replace('.', ',').replace('X', '.'))
    
    # Resumo mensal
    st.subheader("üìÖ Resumo Mensal")
    
    if not df.empty and 'year_month' in df.columns:
        monthly_summary = df.groupby('year_month').agg({
            'amount': [
                ('Entradas', lambda x: x[x > 0].sum()),
                ('Sa√≠das', lambda x: x[x < 0].sum()),
                ('Saldo', 'sum')
            ]
        }).round(2)
        
        monthly_summary.columns = ['Entradas', 'Sa√≠das', 'Saldo']
        monthly_summary['M√™s'] = monthly_summary.index.astype(str)
        monthly_summary = monthly_summary[['M√™s', 'Entradas', 'Sa√≠das', 'Saldo']]
        
        # Formatar valores
        for col in ['Entradas', 'Sa√≠das', 'Saldo']:
            monthly_summary[col] = monthly_summary[col].apply(
                lambda x: f"R$ {x:,.2f}".replace(',', 'X').replace('.', ',').replace('X', '.')
            )
        
        st.dataframe(monthly_summary, use_container_width=True, hide_index=True)
    
    # Todas as transa√ß√µes
    st.subheader("üí≥ Todas as Transa√ß√µes")
    
    df_display = df.copy()
    df_display['Data'] = df_display['date'].dt.strftime('%d/%m/%Y')
    df_display['Valor'] = df_display['amount'].apply(
        lambda x: f"R$ {abs(x):,.2f}".replace(',', 'X').replace('.', ',').replace('X', '.') + 
                 (' üî¥' if x < 0 else ' üü¢')
    )
    
    st.dataframe(
        df_display[['Data', 'description', 'Valor', 'category']].rename(
            columns={'description': 'Descri√ß√£o', 'category': 'Categoria'}
        ),
        use_container_width=True,
        hide_index=True,
        height=min(600, 35 * len(df_display) + 38)
    )
    
    # Bot√£o para exportar dados
    if st.button("üì§ Exportar para Excel"):
        csv = df_display[['Data', 'Descri√ß√£o', 'Valor', 'Categoria']].to_csv(index=False)
        st.download_button(
            label="‚¨áÔ∏è Baixar CSV",
            data=csv,
            file_name="extrato_analisado.csv",
            mime="text/csv"
        )

else:
    st.info("üìÅ Fa√ßa o upload dos extratos PDF e clique em 'Processar Extratos'")

# Mensagem de status
if uploaded_files and st.session_state.transactions.empty:
    st.warning("""
    ‚ö†Ô∏è Nenhuma transa√ß√£o foi encontrada. Isso pode acontecer por:
    
    1. üîë Problema com a chave API do Gemini
    2. üìÑ PDFs escaneados (imagens) em vez de texto
    3. üè¶ Formato de extrato muito diferente
    4. üåê Problema de conex√£o com a API
    
    **Solu√ß√£o:** Verifique se os PDFs cont√™m texto selecion√°vel e tente novamente.
    """)
